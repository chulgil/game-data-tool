import os
import logging
import shutil
from re import match
from typing import Optional

import pymsteams as pymsteams
import yaml
from dateutil import parser
from pathlib import Path


class CSharpManager:

    def __init__(self, branch: str, commit_id: str, save_dir: Path):
        self.BRANCH = branch
        self.COMMIT_ID = commit_id
        self._error_msg = []
        self._info = f'[{branch} 브랜치]'
        self.ROOT_DIR = Path(__file__).parent.parent
        self.PATH_FOR_SAVE = save_dir
        self.PATH_FOR_CONFIG = self.ROOT_DIR.joinpath('config.yaml')
        self.PATH_FOR_CSHARP = self.PATH_FOR_SAVE.joinpath('GENERATED_DATA.cs')
        # Config 파일 설정
        with open(self.PATH_FOR_CONFIG, 'r') as f:
            config = yaml.safe_load(f)
        self._set_config(config)

    def _set_config(self, config):
        self.teams = pymsteams.connectorcard(config['TEAMS']['DESIGNER_URL'])

    def save(self, table_info: dict):
        table_name = ''
        schema = self._get_default_csharp()
        for key in table_info.keys():
            table_name = str(key).upper()
            rows = table_info[key]
            new_schema = self._convet_csharp(table_name, rows)
            if new_schema != '':
                logging.info(f'{self._info} 스키마 저장 완료: {table_name}')
                schema = schema + new_schema

        with open(self.PATH_FOR_CSHARP, "w", encoding='utf-8') as f:
            f.write(schema)

        # try:
        #     # 지정한 경로로 Prisma 스키마 파일 저장
        #     with open(self.PATH_FOR_CSHARP, "w", encoding='utf-8') as f:
        #         f.write(schema)
        # except Exception as e:
        #     logging.error(f'{self._info} 스키마 저장 Error: {table_name}\n{str(e)}')

    def _convet_csharp(self, table_name: str, rows: list) -> str:
        """
        C# 스크립트 포멧으로 변환 :
        디비필드, 디비타입, 스키마타입
        ['id', 'long', '@auto'] -> ['id', 'int', '@auto']
        """
        schema = ''
        try:
            tab = '    '

            schema = schema + f'\npublic class {table_name} ' + '\n{\n'
            if len(rows) < 1:
                return ''
            for row in rows:
                # 순서 주의 : 컨버팅 되지 않은 타입값으로 디비 스키마 값 변경
                d_type = self._convert_datatype(row[1], row[2])
                field = row[0]
                desc = str(row[3]).replace('\n', ' ')  # 메모의 개행 공백 치환
                schema = schema + tab + f'public {d_type} {field} ' + '{ get; private set; } '
                schema = schema + ('// ' + desc + '\n' if desc != '' else '\n')
            schema = schema + '}\n'

            print(schema)
        
        except Exception as e:
            logging.error(f'{self._info} 스키마 변환 Error: {table_name}\n{str(e)}')
        return schema

    @staticmethod
    def _convert_datatype(col: str, option: str) -> str:
        res = col.lower()
        if res == 'bool' or res == 'boolean':
            res = 'bool'
        elif res == 'datetime':
            res = 'DateTime'

        from re import match
        if match(r'@null', option):
            res = res + '?'
        return res

    def _get_default_csharp(self):
        return '''
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Commit ID: {0}
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
        
using System;
using System.IO;
using UnityEngine;
        
        '''.format(self.COMMIT_ID)
